<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>XINX Library: XINX Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>XINX Library </h1><h3 class="version">0.9.0 </h3><h2><a class="anchor" id="preface">
Preface</a></h2>
<p>This document explain how to use the XINX Library to create a plugins. This document can be used to known how XINX work too.</p>
<p>You can find in the menu, documented class present in the libxinxcmp and libsharedxinx. The first library contains components, the second, contains shared object beetween XINX and plugins. Source of existing plugins can be use too, as documentation.</p>
<p>Plugins is used to extend XINX in different way.</p>
<ul>
<li>Add a revision control system</li>
<li>Add Syntax Highlighter on file editor</li>
<li>Add a new editor (text, graphics, ...)</li>
</ul>
<h2><a class="anchor" id="pluginbase">
Base of plugin</a></h2>
<p>A plugins must implements at least one interface : <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em>. This interface is used to know informations about the plugins. A plugin that implement only this interface do nothing but is recognize by XINX (see EmptyPlugin exemple).</p>
<p>To implemente the interface you must write some code like this : </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FooPlugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a> {
  Q_OBJECT
  Q_INTERFACES(<a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>)
 public:
  FooPlugin();
  virtual ~FooPlugin();

  virtual <span class="keywordtype">bool</span> initializePlugin( const QString &amp; lang );
  virtual QVariant getPluginAttribute( const enum <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>::PluginAttribute &amp; attr );
 };
</pre></div><p>The implementation of this class can be :</p>
<div class="fragment"><pre class="fragment"> FooPlugin::FooPlugin() {
  <span class="comment">// Make some initialization</span>
 }

 FooPlugin::~FooPlugin() {
  <span class="comment">// Make some cleanup</span>
 }

 <span class="keywordtype">bool</span> <a class="code" href="classIXinxPlugin.html#ac5ab3860816308bbf1bf0fd1d0056743">FooPlugin::initializePlugin</a>( <span class="keyword">const</span> QString &amp; lang ) {
  <span class="comment">// Make some initialization about the localization</span>
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
 }

 QVariant <a class="code" href="classIXinxPlugin.html#af005f6454313e0dd9fcdf8cfc02de49f">FooPlugin::getPluginAttribute</a>( <span class="keyword">const</span> <span class="keyword">enum</span> <a class="code" href="classIXinxPlugin.html#a19c69c38ee88557f23dfb9f91ab26a60">IXinxPlugin::PluginAttribute</a> &amp; attr ) {
  <span class="keywordflow">switch</span>( attr ) {
  <span class="keywordflow">case</span> PLG_NAME:
      <span class="keywordflow">return</span> tr(<span class="stringliteral">&quot;A foo plugins&quot;</span>);
  <span class="keywordflow">case</span> PLG_DESCRIPTION:
      <span class="keywordflow">return</span> tr(<span class="stringliteral">&quot;Just a foo plugins that do nothing.&quot;</span>);
  <span class="keywordflow">case</span> PLG_AUTHOR:
      <span class="keywordflow">return</span> <span class="stringliteral">&quot;Ulrich Van Den Hekke&quot;</span>;
  <span class="keywordflow">case</span> PLG_VERSION:
      <span class="keywordflow">return</span> <span class="stringliteral">&quot;0.1&quot;</span>;
  <span class="keywordflow">case</span> PLG_LICENCE:
      <span class="keywordflow">return</span> <span class="stringliteral">&quot;GPL v2.0 or later&quot;</span>;
  }
  <span class="keywordflow">return</span> QVariant();
 }
 <a class="code" href="xinxdesignerplugin_8cpp.html#aeb0403b30c08b12a41000eb04520e405">Q_EXPORT_PLUGIN2</a>(fooplugin, FooPlugin)
</pre></div><p>The plugins must inherits from the <em>QObject</em> class (see Qt documentation), and must call the <em>Q_OBJECT</em> macro. <em>QObject</em> class give to the class some meta-object methods (to know the name of the class, ... dynamicaly). He can inherits <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em> directly or indirectly (some interface as <em><a class="el" href="classIRCSPlugin.html">IRCSPlugin</a></em> inherits from <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em>).</p>
<p>The plugin must call the <em>Q_EXPORT_PLUGIN2</em> macro in the implementation. This create a static variable for the plugin, created when the library is loading.</p>
<p>If the plugin need to call new tools, you can reimplement <em><a class="el" href="classIXinxPlugin.html#a84298f635f6ead2dda34818656f6164b">IXinxPlugin::pluginTools()</a></em> and returns the list of tool needed by your plugin with the default value (you can have a default value for Gnu/linux and for Windows).</p>
<div class="fragment"><pre class="fragment"> QList&amp;lt; QPair&amp;lt;QString,QString&amp;gt; &amp;gt; CVSPlugin::pluginTools() {
  QList&amp;lt; QPair&amp;lt;QString,QString&amp;gt; &amp;gt; tools;
<span class="preprocessor"> #ifdef Q_WS_WIN</span>
<span class="preprocessor"></span>  tools.append( qMakePair( QString(<span class="stringliteral">&quot;mytool&quot;</span>), QString(<span class="stringliteral">&quot;%1/Tool/mytool.exe&quot;</span>).arg( <span class="stringliteral">&quot;C:/Program Files&quot;</span> ) ) );
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>  tools.append( qMakePair( QString(<span class="stringliteral">&quot;cvs&quot;</span>), QString(<span class="stringliteral">&quot;/usr/bin/mytool&quot;</span>) ) );
<span class="preprocessor"> #endif // Q_WS_WIN</span>
<span class="preprocessor"></span>  <span class="keywordflow">return</span> tools;
 }
</pre></div><p>You can also reimplement <em>IXinxPlugin::initializeProject()</em> and <em>IXinxPlugin::destroyProject()</em> if you have specifique code when the current project is opened or destroyed. This two fonction can be replaced by whatching the signal <em><a class="el" href="classXINXProjectManager.html#ae426cc6f98dc6224a101968793f505cd">XINXProjectManager::changed()</a></em>.</p>
<p>if <em><a class="el" href="classXINXProjectManager.html#a592fa5614f8a37dd501bb5262d9cdb99">XINXProjectManager::self()</a>-&gt;project()</em> is null the plugin is destroyed else, he is created.</p>
<h2><a class="anchor" id="rcsplugin">
The Revision Control System Plugin</a></h2>
<p>A <a class="el" href="classRCS.html">RCS</a> Plugin must implemente the <em><a class="el" href="classIRCSPlugin.html">IRCSPlugin</a></em> interface.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FooPlugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classIRCSPlugin.html">IRCSPlugin</a> {
  Q_OBJECT
  Q_INTERFACES(<a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>)
  Q_INTERFACES(<a class="code" href="classIRCSPlugin.html">IRCSPlugin</a>)
 public:
  FooPlugin();
  virtual ~FooPlugin();

  virtual <span class="keywordtype">bool</span> initializePlugin( const QString &amp; lang );
  virtual QVariant getPluginAttribute( const enum <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>::PluginAttribute &amp; attr );

  virtual QStringList rcs();
  virtual QString descriptionOfRCS( const QString &amp; rcs );
  virtual <a class="code" href="classRCS.html">RCS</a> * createRCS( const QString &amp; rcs, const QString &amp; basePath );
 };
</pre></div><p>In the implementation method create a derivated object of <em><a class="el" href="classRCS.html">RCS</a></em> </p>
<div class="fragment"><pre class="fragment"> QStringList FooPlugin::rcs() {
  <span class="keywordflow">return</span> QStringList() &lt;&lt; <span class="stringliteral">&quot;foo&quot;</span>;
 }

 QString <a class="code" href="classIRCSPlugin.html#ac2a740a756e41d21072e61504664ed30" title="Description of each revision control system.">FooPlugin::descriptionOfRCS</a>( <span class="keyword">const</span> QString &amp; rcs ) {
  <span class="keywordflow">if</span>( rcs.toLower() == <span class="stringliteral">&quot;foo&quot;</span> )
      <span class="keywordflow">return</span> tr( <span class="stringliteral">&quot;Foo - Foo Version System&quot;</span> );
  <span class="keywordflow">return</span> QString();
 }

 <a class="code" href="classRCS.html">RCS</a> * <a class="code" href="classIRCSPlugin.html#a9f8cc1ebffb31e05070ed58191bb2c68">FooPlugin::createRCS</a>( <span class="keyword">const</span> QString &amp; rcs, <span class="keyword">const</span> QString &amp; basePath ) {
  <span class="keywordflow">if</span>( rcs.toLower() == <span class="stringliteral">&quot;foo&quot;</span> ) {
      <span class="keywordflow">return</span> <span class="keyword">new</span> RCS_Foo( basePath );
  }
  <span class="keywordflow">return</span> NULL;
 }
</pre></div><p>Then, in the object RCS_Foo (that inherits from <a class="el" href="classRCS.html">RCS</a>) :</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>RCS_Foo : <span class="keyword">public</span> <a class="code" href="classRCS.html">RCS</a> {
  Q_OBJECT
 <span class="keyword">public</span>:
  RCS_Foo( <span class="keyword">const</span> QString &amp; base );
  <span class="keyword">virtual</span> ~RCS_Foo();

  <span class="keyword">virtual</span> struct_rcs_infos infos( <span class="keyword">const</span> QString &amp; path );
  <span class="keyword">virtual</span> <a class="code" href="classRCS.html#a2a5e4c568a4c455fe90f52553dc1eb14" title="List of FileOperation.">RCS::FilesOperation</a> operations( <span class="keyword">const</span> QStringList &amp; path );
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update( <span class="keyword">const</span> QStringList &amp; path );
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> commit( <span class="keyword">const</span> FilesOperation &amp; path, <span class="keyword">const</span> QString &amp; message );
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> add( <span class="keyword">const</span> QStringList &amp; path );
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>( <span class="keyword">const</span> QStringList &amp; path );
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> updateToRevision( <span class="keyword">const</span> QString &amp; path, <span class="keyword">const</span> QString &amp; revision, QString * content = 0 );
 <span class="keyword">public</span> slots:
  <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort();
 <span class="keyword">private</span> slots:
 <span class="keyword">private</span>:
 };
</pre></div><p>Operations <em><a class="el" href="classRCS.html#a0bdf5a3b7c336ebffa6b19e954c02cc6">RCS::update()</a></em>, <em><a class="el" href="classRCS.html#a79e9bb6d40efa8ed9c72cd71589661d3">RCS::commit()</a></em>, <em><a class="el" href="classRCS.html#ad673781552ac16cf083b418a35c7e158">RCS::add()</a></em>, <em><a class="el" href="classRCS.html#ac2630c6d8cb47fbdc2464b6e865a3dab">RCS::remove()</a></em> and <em><a class="el" href="classRCS.html#affab071302de4e7a272bf1c3e5bfc765">RCS::updateToRevision()</a></em> is the correspponding opperation in the revision manager.</p>
<p><em><a class="el" href="classRCS.html#a5ff5fbbe7e8a74fcff3f430ccfee8030">RCS::operations()</a></em> describe the file than can be Commited, Removed or Added.</p>
<h2><a class="anchor" id="projectconfiguration">
Project configuration plugins</a></h2>
<p>We can configure a plugin throw the <em><a class="el" href="classIXinxPluginConfiguration.html">IXinxPluginConfiguration</a></em> interface, if the configuration is global, or throw the <em><a class="el" href="classIXinxPluginProjectConfiguration.html">IXinxPluginProjectConfiguration</a></em> interface, if the configuration depends on the project.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FooPlugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classIRCSPlugin.html">IRCSPlugin</a>, <span class="keyword">public</span> IRCSPluginProjectConfiguration {
  Q_OBJECT
  Q_INTERFACES(<a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>)
  Q_INTERFACES(<a class="code" href="classIRCSPlugin.html">IRCSPlugin</a>)
  Q_INTERFACES(IRCSPluginProjectConfiguration)
 public:
  FooPlugin();
  virtual ~FooPlugin();
</pre></div><p>Methods <em><a class="el" href="classIXinxPluginConfiguration.html#ac02ecc97065e3ccdf3f08bd46c395c47" title="Create a widget used in a wrapper for the configuration dialog box.">IXinxPluginConfiguration::createSettingsDialog()</a></em> and <em><a class="el" href="classIXinxPluginProjectConfiguration.html#ab704224a188d9da0768f3b206a4f1840" title="Create a widget used in the project dialog.">IXinxPluginProjectConfiguration::createProjectSettingsPage()</a></em> return a widget that will be include in the project configuration box, or in the configuration dialog.</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">virtual</span> QWidget * createProjectSettingsPage() {
    <span class="keywordflow">return</span> <span class="keyword">new</span> FooProjectImpl();
  }
</pre></div><p>The class <em>FooProjectImpl</em> is a dialog box that contains the different CheckBox, RadioButton, ... for configure the dialog.</p>
<p>Settings are load and saved with methods <em>IXinxPluginConfiguration::loadSettingsDialog()</em>, <em>IXinxPluginProjectConfiguration::loadProjectSettingsPage()</em>, <em>IXinxPluginConfiguration::saveSettingsDialog()</em>, and <em>IXinxPluginProjectConfiguration::saveProjectSettingsPage()</em>.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> loadProjectSettingsPage( QWidget * widget ) {
  FooProjectImpl * page = qobject_cast&lt;FooProjectImpl*&gt;( widget );
  Q_ASSERT( page );

  XinxProject::ProjectOptions options = <a class="code" href="classXINXProjectManager.html#a592fa5614f8a37dd501bb5262d9cdb99">XINXProjectManager::self</a>()-&gt;<a class="code" href="classXINXProjectManager.html#a7d0acbe310d2f0a58ea39ebc0a740ba1">project</a>()-&gt;options();
  page-&gt;m_monoption-&gt;setChecked( options.testFlag( XinxProject::hasSpecifiques ) );
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
 }

 <span class="keywordtype">bool</span> saveProjectSettingsPage( QWidget * widget ) {
  FooProjectImpl * page = qobject_cast&lt;FooProjectImpl*&gt;( widget );
  Q_ASSERT( page );

  XinxProject::ProjectOptions options = <a class="code" href="classXINXProjectManager.html#a592fa5614f8a37dd501bb5262d9cdb99">XINXProjectManager::self</a>()-&gt;<a class="code" href="classXINXProjectManager.html#a7d0acbe310d2f0a58ea39ebc0a740ba1">project</a>()-&gt;options();
  <span class="keywordflow">if</span>( page-&gt;m_monoption-&gt;isChecked() )
      options |= XinxProject::hasSpecifiques;
  <span class="keywordflow">else</span>
      options &amp;= ~<a class="code" href="classXinxProject.html">XinxProject</a>::hasSpecifiques;
  <a class="code" href="classXINXProjectManager.html#a592fa5614f8a37dd501bb5262d9cdb99">XINXProjectManager::self</a>()-&gt;<a class="code" href="classXINXProjectManager.html#a7d0acbe310d2f0a58ea39ebc0a740ba1">project</a>()-&gt;setOptions( options );
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
 }
</pre></div><p>If you want to add page in the new project wizard dialog, the plugin <em><a class="el" href="classIXinxPluginProjectConfiguration.html">IXinxPluginProjectConfiguration</a></em> give you too, two method who works in the same way that previous : * <em>createNewProjectSettingsPages()</em> * <em>saveNewProjectSettingsPage()</em> </p>
<h2><a class="anchor" id="neweditor">
Creation of a new editor</a></h2>
<p>It's possible to create a new editor with the interface <em><a class="el" href="classIFileTypePlugin.html">IFileTypePlugin</a></em> and <em><a class="el" href="classIFilePlugin.html">IFilePlugin</a></em>. The interface <em><a class="el" href="classIFileTypePlugin.html">IFileTypePlugin</a></em> define for one type of file the mask to use (ie: *.foo) with the function <a class="el" href="classIFileTypePlugin.html#a774d251387cee7dac46148c1d0f79caa" title="Used to choose a file in a dialog box.">IFileTypePlugin::match()</a>, a description (used in open/save dialog box and new menu), an icon and some default properties (than user can modify).</p>
<p>Then the two principal method <em><a class="el" href="classIFileTypePlugin.html#a7046db4c3cbdae6d2c7b86e36f39b8bb" title="Create an editor with the given filename.">IFileTypePlugin::createEditor()</a></em> and <em>IFileTypePlugin::createElement()</em> is used to create the editor, and a content element (used in import, in the content view list).</p>
<p>Interface <em><a class="el" href="classIFilePlugin.html">IFilePlugin</a></em> is just a list of <a class="el" href="classIFileTypePlugin.html">IFileTypePlugin</a>. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Mar 28 15:06:20 2010 for XINX Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
