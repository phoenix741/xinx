<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>XINX Library: XINX Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>XINX Library</h1>
<p>
<h3 align="center">0.7.1 </h3><h2><a class="anchor" name="preface">
Preface</a></h2>
This document explain how to use the XINX Library to create a plugins. This document can be used to known how XINX work, in part, too.<p>
You can find in the menu, documented class present in the libxinxcmp and libsharedxinx. The first library contains components, the second, contains shared object beetween XINX and plugins. Source of existing plugins can be use too, as documentation.<p>
Plugins is used to extend XINX in different way.<ul>
<li>Add a revision control system</li><li>Add Syntax Highlighter on file editor</li><li>Add new editor</li></ul>
<h2><a class="anchor" name="pluginbase">
Base of plugin</a></h2>
A plugins must implements at least one interface : <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em>. This interface is used to know informations about the plugins. A plugin that implement only this interface do nothing but is regocgnize by XINX.<p>
To implemente the interface you must write some code like this : <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FooPlugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a> {
        Q_OBJECT
        Q_INTERFACES(<a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>)
 public:
        FooPlugin();
        virtual ~FooPlugin();

        virtual <span class="keywordtype">bool</span> initializePlugin( const QString &amp; lang );
        virtual QVariant getPluginAttribute( const enum <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>::PluginAttribute &amp; attr );
 };
</pre></div><p>
The implementation of this class can be :<p>
<div class="fragment"><pre class="fragment"> FooPlugin::FooPlugin() {
        <span class="comment">// Make some initialization</span>
 }

 FooPlugin::~FooPlugin() {
        <span class="comment">// Make some cleanup</span>
 }

 <span class="keywordtype">bool</span> <a class="code" href="classIXinxPlugin.html#c5ab3860816308bbf1bf0fd1d0056743">FooPlugin::initializePlugin</a>( <span class="keyword">const</span> QString &amp; lang ) {
        <span class="comment">// Make some initialization about the localization</span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
 }

 QVariant <a class="code" href="classIXinxPlugin.html#f005f6454313e0dd9fcdf8cfc02de49f">FooPlugin::getPluginAttribute</a>( <span class="keyword">const</span> <span class="keyword">enum</span> <a class="code" href="classIXinxPlugin.html#19c69c38ee88557f23dfb9f91ab26a60">IXinxPlugin::PluginAttribute</a> &amp; attr ) {
        <span class="keywordflow">switch</span>( attr ) {
        <span class="keywordflow">case</span> PLG_NAME:
                <span class="keywordflow">return</span> tr(<span class="stringliteral">"A foo plugins"</span>);
        <span class="keywordflow">case</span> PLG_DESCRIPTION:
                <span class="keywordflow">return</span> tr(<span class="stringliteral">"Just a foo plugins that do nothing."</span>);
        <span class="keywordflow">case</span> PLG_AUTHOR:
                <span class="keywordflow">return</span> <span class="stringliteral">"Ulrich Van Den Hekke"</span>;
        <span class="keywordflow">case</span> PLG_VERSION:
                <span class="keywordflow">return</span> <span class="stringliteral">"0.1"</span>;
        <span class="keywordflow">case</span> PLG_LICENCE:
                <span class="keywordflow">return</span> <span class="stringliteral">"GPL v2.0 or later"</span>;
        }
        <span class="keywordflow">return</span> QVariant();
 }
 Q_EXPORT_PLUGIN2(fooplugin, FooPlugin)
</pre></div><p>
The plugins must inherits from the <em>QObject</em> class (see Qt documentation), and must call the <em>Q_OBJECT</em> macro. He can inherits <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em> indirectly (some interface as <em><a class="el" href="classIRCSPlugin.html">IRCSPlugin</a></em> inherits from <em><a class="el" href="classIXinxPlugin.html">IXinxPlugin</a></em>).<p>
The plugin must call the <em>Q_EXPORT_PLUGIN2</em> macro in the implementation. This create a static variable for the plugin.<p>
If the plugin need to call new tools, you can reimplement <em><a class="el" href="classIXinxPlugin.html#84298f635f6ead2dda34818656f6164b">IXinxPlugin::pluginTools()</a></em> and returns the list of tool needed by your plugin with the default value.<p>
You can also reimplement <em><a class="el" href="classIXinxPlugin.html#311b09c37ddd149f3dbab15a2aca0d91" title="Call when a new project is created or opened.">IXinxPlugin::initializeProject()</a></em> and <em><a class="el" href="classIXinxPlugin.html#e88985de2a29f875f9999237cd99ba8b" title="! Call before the project is closed">IXinxPlugin::destroyProject()</a></em> if you have specifique code when the current project is opened or destroyed.<p>
A plugin can propose a configuration dialog throw the <em><a class="el" href="classIXinxPluginConfiguration.html">IXinxPluginConfiguration</a></em> interface.<h2><a class="anchor" name="rcsplugin">
The Revision Control System Plugin</a></h2>
A <a class="el" href="classRCS.html">RCS</a> Plugin must implemente the <a class="el" href="classIRCSPlugin.html">IRCSPlugin</a> interface.<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FooPlugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classIRCSPlugin.html">IRCSPlugin</a> {
        Q_OBJECT
        Q_INTERFACES(<a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>)
        Q_INTERFACES(<a class="code" href="classIRCSPlugin.html">IRCSPlugin</a>)
 public:
        FooPlugin();
        virtual ~FooPlugin();

        virtual <span class="keywordtype">bool</span> initializePlugin( const QString &amp; lang );
        virtual QVariant getPluginAttribute( const enum <a class="code" href="classIXinxPlugin.html">IXinxPlugin</a>::PluginAttribute &amp; attr );

        virtual QStringList rcs();
        virtual QString descriptionOfRCS( const QString &amp; rcs );
        virtual <a class="code" href="classRCS.html">RCS</a> * createRCS( const QString &amp; rcs, const QString &amp; basePath );
 };
</pre></div><p>
In the implementation method create a derivated object of <a class="el" href="classRCS.html">RCS</a><p>
<div class="fragment"><pre class="fragment"> QStringList <a class="code" href="classIRCSPlugin.html#7ab4240b80ee1c77c392536d544faaff" title="List of revision control system proposed by the plugin.">FooPlugin::rcs</a>() {
        <span class="keywordflow">return</span> QStringList() &lt;&lt; <span class="stringliteral">"foo"</span>;
 }

 QString <a class="code" href="classIRCSPlugin.html#c2a740a756e41d21072e61504664ed30" title="Description of each revision control system.">FooPlugin::descriptionOfRCS</a>( <span class="keyword">const</span> QString &amp; rcs ) {
        <span class="keywordflow">if</span>( rcs.toLower() == <span class="stringliteral">"foo"</span> )
                <span class="keywordflow">return</span> tr( <span class="stringliteral">"Foo - Foo Version System"</span> );
        <span class="keywordflow">return</span> QString();
 }

 <a class="code" href="classRCS.html">RCS</a> * <a class="code" href="classIRCSPlugin.html#e2ad1869428d5cf6a0f226e2c96aec7a">FooPlugin::createRCS</a>( <span class="keyword">const</span> QString &amp; rcs, <span class="keyword">const</span> QString &amp; basePath ) {
        <span class="keywordflow">if</span>( rcs.toLower() == <span class="stringliteral">"foo"</span> ) {
                <span class="keywordflow">return</span> <span class="keyword">new</span> RCS_Foo( basePath );
        }
        <span class="keywordflow">return</span> NULL;
 }
</pre></div><p>
Next this is the RCS_Foo object that will be used in the application to <em>update</em>, <em>commit</em>, <em>remove</em> and <em>add</em>.<h2><a class="anchor" name="projectconfiguration">
Project configuration plugins</a></h2>
We can configure a plugin throw the <em><a class="el" href="classIXinxPluginConfiguration.html">IXinxPluginConfiguration</a></em> interface, if the configuration is global, or throw the <em><a class="el" href="classIXinxPluginProjectConfiguration.html">IXinxPluginProjectConfiguration</a></em> interface, if the configuration depends on the project.<p>
Methods <em><a class="el" href="classIXinxPluginConfiguration.html#f425a2a62642f79cc57718cc2fc8568c" title="Create a widget used in a wrapper for the configuration dialog box.">IXinxPluginConfiguration::createSettingsDialog()</a></em> and <em><a class="el" href="classIXinxPluginProjectConfiguration.html#7358ad14e86ea04e3aafc2f0eba44590" title="Create a widget used in the project dialog.">IXinxPluginProjectConfiguration::createProjectSettingsPage()</a></em> return a widget thar will be include in the project configuration box, or in the configuration dialog.<p>
Settings are load and saved with methods <em>loadSettingsDialog()</em>, <em>loadProjectSettingsPage()</em>, <em>saveSettingsDialog()</em>, and <em>saveProjectSettingsPage()</em>.<p>
If you want to add page in the new project wizard dialog, the plugin <a class="el" href="classIXinxPluginProjectConfiguration.html">IXinxPluginProjectConfiguration</a> give you too, two method : * <em>createNewProjectSettingsPages()</em> * <em>saveNewProjectSettingsPage()</em> <h2><a class="anchor" name="neweditor">
Creation of a new editor</a></h2>
It's possible to create a new editor with the interface <em><a class="el" href="classIFileTypePlugin.html">IFileTypePlugin</a></em> and <em><a class="el" href="classIFilePlugin.html">IFilePlugin</a></em> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Aug 23 14:51:31 2008 for XINX Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
